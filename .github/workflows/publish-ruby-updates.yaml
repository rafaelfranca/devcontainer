name: Publish Ruby Updates

on:
  push:
    branches:
      - main

jobs:
  detect-ruby-update:
    runs-on: ubuntu-latest
    if: contains(github.event.head_commit.message, '[automated-ruby-update]')
    outputs:
      has_feature_bump: ${{ steps.check-bump.outputs.has_bump }}
      old_version: ${{ steps.check-bump.outputs.old_version }}
      new_version: ${{ steps.check-bump.outputs.new_version }}
      new_ruby_versions: ${{ steps.extract-versions.outputs.new_versions }}
      current_image_version: ${{ steps.get-image-version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit to compare

      - name: Check for feature version bump
        id: check-bump
        run: |
          if RESULT=$(bin/check-feature-bump); then
            echo "Feature version was bumped!"
            echo "has_bump=true" >> $GITHUB_OUTPUT
            echo "old_version=$(echo "$RESULT" | jq -r '.old_version')" >> $GITHUB_OUTPUT
            echo "new_version=$(echo "$RESULT" | jq -r '.new_version')" >> $GITHUB_OUTPUT
          else
            echo "No feature version bump"
            echo "has_bump=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract new Ruby versions from diff
        id: extract-versions
        run: |
          echo "Extracting newly added Ruby versions..."

          NEW_VERSIONS_JSON=$(bin/extract-new-ruby-versions json)

          if [ "$NEW_VERSIONS_JSON" = "[]" ]; then
            echo "No new Ruby versions found in diff"
            echo "new_versions=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "New Ruby versions:"
          echo "$NEW_VERSIONS_JSON" | jq -r '.[]'
          echo "JSON array: $NEW_VERSIONS_JSON"

          echo "new_versions=$NEW_VERSIONS_JSON" >> $GITHUB_OUTPUT

      - name: Get current image version
        id: get-image-version
        run: |
          IMAGE_VERSION=$(bin/get-current-image-version)
          echo "Current image version: $IMAGE_VERSION"
          echo "version=$IMAGE_VERSION" >> $GITHUB_OUTPUT

  publish-feature:
    needs: detect-ruby-update
    if: needs.detect-ruby-update.outputs.has_feature_bump == 'true'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: write
      packages: write
      pull-requests: write
    outputs:
      feature_tag: ${{ steps.get-tag.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Publish Ruby feature
        uses: devcontainers/action@v1
        with:
          publish-features: "true"
          generate-docs: "true"
          base-path-to-features: "./features/src/ruby"
          features-namespace: "rails/devcontainer/features"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for feature tag creation
        id: get-tag
        run: |
          VERSION="${{ needs.detect-ruby-update.outputs.new_version }}"
          EXPECTED_TAG="feature_ruby_${VERSION}"

          echo "Waiting for tag: $EXPECTED_TAG"

          # Wait up to 60 seconds for the tag to be created
          for i in {1..12}; do
            if git ls-remote --tags origin | grep -q "refs/tags/$EXPECTED_TAG"; then
              echo "Tag $EXPECTED_TAG found!"
              echo "tag=$EXPECTED_TAG" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Waiting for tag... (attempt $i/12)"
            sleep 5
          done

          echo "Warning: Tag $EXPECTED_TAG not found after 60 seconds"
          echo "tag=$EXPECTED_TAG" >> $GITHUB_OUTPUT

  create-feature-release:
    needs: [detect-ruby-update, publish-feature]
    if: needs.detect-ruby-update.outputs.has_feature_bump == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create GitHub Release for feature
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.publish-feature.outputs.feature_tag }}"
          VERSION="${{ needs.detect-ruby-update.outputs.new_version }}"

          echo "Creating release for $TAG..."

          gh release create "$TAG" \
            --title "Ruby Feature $VERSION" \
            --generate-notes \
            --notes "Published Ruby devcontainer feature version $VERSION to \`ghcr.io/rails/devcontainer/features/ruby:$VERSION\`" \
            || echo "Release may already exist or tag not found yet"

  publish-full-image:
    needs: [detect-ruby-update, publish-feature, create-feature-release]
    if: needs.detect-ruby-update.outputs.has_feature_bump == 'true'
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: write
    outputs:
      image_tag: ${{ steps.create-tag.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create and push image tag
        id: create-tag
        run: |
          VERSION="${{ needs.detect-ruby-update.outputs.new_version }}"
          IMAGE_TAG="ruby-${VERSION}"

          echo "Creating image tag: $IMAGE_TAG"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag "$IMAGE_TAG"
          git push origin "$IMAGE_TAG"

          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Wait for image build completion
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          IMAGE_TAG="${{ steps.create-tag.outputs.tag }}"

          echo "Waiting for image build workflow to start..."
          sleep 10

          # Find the workflow run triggered by our tag
          RUN_ID=$(gh run list --workflow "publish-new-image-version.yaml" \
            --json databaseId,headBranch,status \
            --jq ".[] | select(.headBranch == \"$IMAGE_TAG\") | .databaseId" | head -n 1)

          if [ -n "$RUN_ID" ]; then
            echo "Found workflow run: $RUN_ID"
            echo "Watching workflow run..."
            gh run watch "$RUN_ID" --exit-status
          else
            echo "Warning: Could not find workflow run for tag $IMAGE_TAG"
          fi

  create-image-release:
    needs: [detect-ruby-update, publish-full-image]
    if: needs.detect-ruby-update.outputs.has_feature_bump == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create GitHub Release for image
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.publish-full-image.outputs.image_tag }}"
          VERSION="${{ needs.detect-ruby-update.outputs.new_version }}"

          echo "Creating release for $TAG..."

          gh release create "$TAG" \
            --title "Ruby Image $VERSION" \
            --generate-notes \
            --notes "Published Ruby devcontainer images for all supported Ruby versions with feature version $VERSION. \n
            Images are available at \`ghcr.io/rails/devcontainer/images/ruby\` with tags like \`$VERSION-3.3.0\`, \`$VERSION-3.4.0\`, etc."

  publish-new-ruby-versions:
    needs: detect-ruby-update
    if: needs.detect-ruby-update.outputs.has_feature_bump == 'false' && needs.detect-ruby-update.outputs.new_ruby_versions != ''
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Trigger publish new Ruby versions workflow
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSIONS='${{ needs.detect-ruby-update.outputs.new_ruby_versions }}'
          IMAGE_VERSION='["${{ needs.detect-ruby-update.outputs.current_image_version }}"]'

          echo "Triggering workflow for new Ruby versions:"
          echo "Ruby versions: $NEW_VERSIONS"
          echo "Image version: $IMAGE_VERSION"

          gh workflow run publish-new-ruby-versions.yaml \
            -f ruby_versions="$NEW_VERSIONS" \
            -f image_versions="$IMAGE_VERSION"

          echo "Workflow triggered successfully!"

  notify-failure:
    needs: [detect-ruby-update, publish-feature, create-feature-release, publish-full-image, create-image-release, publish-new-ruby-versions]
    if: failure()
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Create issue on failure
        uses: actions/github-script@v7
        with:
          script: |
            const jobs = {
              'detect-ruby-update': '${{ needs.detect-ruby-update.result }}',
              'publish-feature': '${{ needs.publish-feature.result }}',
              'create-feature-release': '${{ needs.create-feature-release.result }}',
              'publish-full-image': '${{ needs.publish-full-image.result }}',
              'create-image-release': '${{ needs.create-image-release.result }}',
              'publish-new-ruby-versions': '${{ needs.publish-new-ruby-versions.result }}'
            };

            const failedJobs = Object.entries(jobs)
              .filter(([_, result]) => result === 'failure')
              .map(([name, _]) => name);

            const body = `The automated Ruby publishing workflow failed.

            **Failed Jobs:** ${failedJobs.join(', ') || 'Unknown'}

            **Run:** ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}

            **Commit:** ${context.sha.substring(0, 7)} - ${context.payload.head_commit.message.split('\n')[0]}

            Please check the workflow logs for details and retry manually if needed.`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸ”´ Ruby Publishing Workflow Failed',
              body: body,
              labels: ['automation', 'bug', 'ruby-versions']
            });
